package xyz.pixelatedw.mineminenomi.events.devilfruits;

import net.minecraft.entity.Entity;
import net.minecraft.entity.LivingEntity;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.entity.projectile.ArrowEntity;
import net.minecraft.item.ItemStack;
import net.minecraft.item.Items;
import net.minecraft.util.DamageSource;
import net.minecraftforge.event.entity.living.LivingAttackEvent;
import net.minecraftforge.eventbus.api.SubscribeEvent;
import xyz.pixelatedw.mineminenomi.api.WyHelper;
import xyz.pixelatedw.mineminenomi.api.abilities.Ability;
import xyz.pixelatedw.mineminenomi.api.abilities.AbilityAttribute;
import xyz.pixelatedw.mineminenomi.api.abilities.AbilityProjectile;
import xyz.pixelatedw.mineminenomi.api.data.abilitydata.AbilityDataCapability;
import xyz.pixelatedw.mineminenomi.api.data.abilitydata.IAbilityData;
import xyz.pixelatedw.mineminenomi.config.CommonConfig;
import xyz.pixelatedw.mineminenomi.data.entity.devilfruit.DevilFruitCapability;
import xyz.pixelatedw.mineminenomi.data.entity.devilfruit.IDevilFruit;
import xyz.pixelatedw.mineminenomi.entities.mobs.EntityNewMob;
import xyz.pixelatedw.mineminenomi.helpers.DevilFruitsHelper;
import xyz.pixelatedw.mineminenomi.init.ModAttributes;
import xyz.pixelatedw.mineminenomi.init.ModMiscBlocks;
import xyz.pixelatedw.mineminenomi.init.ModNetwork;
import xyz.pixelatedw.mineminenomi.init.ModWeapons;
import xyz.pixelatedw.mineminenomi.packets.PacketParticles;

public class EventsLogiaInvulnerability
{
	@SubscribeEvent
	public void onEntityAttackEvent(LivingAttackEvent event)
	{
		LivingEntity entity = event.getEntityLiving();
		DamageSource damageSource  = event.getSource();
		Entity sourceOfDamage = damageSource.getTrueSource();
		ItemStack heldItem = null;
		
		boolean entityIsLogia = false;
		String entityUsedFruit = "n/a";
		
		IAbilityData abilityDataProps;
		IDevilFruit devilFruitPropz;
		IDevilFruit devilFruitProps = DevilFruitCapability.get(entity);
		
		if(devilFruitProps != null)
		{
			entityIsLogia = devilFruitProps.isLogia();
			entityUsedFruit = devilFruitProps.getDevilFruit();
		}
		
		boolean attackerHasKairosekiWeapon = false;
		boolean attackerHasHaki = false;
		String attackerUsedFruit = "";
		
		if(sourceOfDamage instanceof PlayerEntity)
		{
			devilFruitPropz = DevilFruitCapability.get((LivingEntity) sourceOfDamage);
			abilityDataProps = AbilityDataCapability.get((LivingEntity) sourceOfDamage);
			Ability busoHaki = abilityDataProps.getHotbarAbilityFromName(ModAttributes.BUSOSHOKU_HAKI.getAttributeName());
			boolean hasBusoHakiActive = (busoHaki != null && busoHaki.isPassiveActive());
			attackerHasHaki = hasBusoHakiActive;
			attackerUsedFruit = devilFruitPropz.getDevilFruit();
			heldItem = ((PlayerEntity) sourceOfDamage).getHeldItemMainhand();
			if(heldItem != null)
			{
				attackerHasKairosekiWeapon = false;//heldItem.isEnchanted() && EnchantmentHelper.getEnchantmentLevel(ListEffects.kairoseki.effectId, heldItem) > 0;	

				if(heldItem.getItem() == ModWeapons.jitte)
					attackerHasKairosekiWeapon = true;			
			}
		}
		else if(sourceOfDamage instanceof EntityNewMob)
		{
			devilFruitPropz = DevilFruitCapability.get((LivingEntity) sourceOfDamage);
			abilityDataProps = AbilityDataCapability.get((LivingEntity) sourceOfDamage);
			Ability busoHaki = abilityDataProps.getHotbarAbilityFromName(ModAttributes.BUSOSHOKU_HAKI.getAttributeName());
			boolean hasBusoHakiActive = (busoHaki != null && busoHaki.isPassiveActive());
			attackerHasHaki = hasBusoHakiActive;
			heldItem = ((EntityNewMob) sourceOfDamage).getHeldItemMainhand();
			attackerUsedFruit = devilFruitPropz.getDevilFruit();
			//TODO Check if mobs have kairoseki weapons
			if(heldItem != null)
				attackerHasKairosekiWeapon = false;
		}

		if(sourceOfDamage instanceof LivingEntity)
		{
			if(entityIsLogia && !kairosekiChecks(entity) && !attackerHasHaki && !attackerHasKairosekiWeapon)
			{
				if(entityUsedFruit.equalsIgnoreCase("gorogoro") && attackerUsedFruit.equalsIgnoreCase("gomugomu"))
					return;
				
				event.setCanceled(true);
				ModNetwork.sendToAllAround(new PacketParticles("logiaEffect_" + entityUsedFruit, entity), entity);
			}
			else
			{
				if(sourceOfDamage instanceof PlayerEntity)
				{
					abilityDataProps = AbilityDataCapability.get((PlayerEntity) sourceOfDamage);
					
					if(!sourceOfDamage.world.isRemote && (heldItem == ItemStack.EMPTY || heldItem == Items.AIR.getDefaultInstance()))
					{
						for(int i = 0; i < abilityDataProps.countAbilitiesInHotbar(); i++)
						{
							if(abilityDataProps.getHotbarAbilityFromSlot(i) != null && !abilityDataProps.getHotbarAbilityFromSlot(i).isOnCooldown() 
									&& abilityDataProps.getHotbarAbilityFromSlot(i).getAttribute().isPassive() && abilityDataProps.getHotbarAbilityFromSlot(i).isPassiveActive())
							{		
								if(abilityDataProps.getHotbarAbilityFromSlot(i).getAttribute().isPunch())
								{		
									abilityDataProps.getHotbarAbilityFromSlot(i).hitEntity((PlayerEntity) sourceOfDamage, entity);
								}
							}
						}
					}
				}
			}
		}

		if(sourceOfDamage instanceof ArrowEntity && entityIsLogia && CommonConfig.instance.getLogiaInvulnerability() && !this.kairosekiChecks(entity))
			event.setCanceled(true);
		
		if(sourceOfDamage instanceof AbilityProjectile && entityIsLogia && CommonConfig.instance.getLogiaInvulnerability() && !this.kairosekiChecks(entity))
		{
			AbilityAttribute attr = ((AbilityProjectile)sourceOfDamage).getAttribute();		
			
			if(attr.getAttributeName().equals("Bullet"))
				event.setCanceled(true);
		}
		
		if(damageSource.isExplosion() && entityIsLogia && CommonConfig.instance.getLogiaInvulnerability() && !this.kairosekiChecks(entity))
			event.setCanceled(true);
		
		if(entityUsedFruit.equalsIgnoreCase("meramera") && (damageSource.equals(DamageSource.IN_FIRE) || damageSource.equals(DamageSource.ON_FIRE)))
		{
			entity.extinguish();
			event.setCanceled(true);
		}
		
		if(entityUsedFruit.equalsIgnoreCase("magumagu") && (damageSource.equals(DamageSource.IN_FIRE) || damageSource.equals(DamageSource.ON_FIRE) || damageSource.equals(DamageSource.LAVA)))
		{
			entity.extinguish();
			event.setCanceled(true);
		}
	}
	
	private boolean kairosekiChecks(LivingEntity entity)
	{
		if(entity instanceof PlayerEntity)
		{
			PlayerEntity PlayerEntity = (PlayerEntity) entity;
			return DevilFruitsHelper.isNearbyKairoseki(PlayerEntity);
		}
		else
		{
			return WyHelper.isBlockNearby(entity, 3, ModMiscBlocks.kairosekiBlock, ModMiscBlocks.kairosekiOre, ModMiscBlocks.kairosekiBars);
		}
	}
}
